//Jun/9/2018 ac 16ms beats 60% 思路参考网上
//经典的关于字典序的问题，之前考试没做出来
//思路是：先找到不满足局部最大字典序的位置（从后向前，当有一位不满足nums[i]>nums[i-1]时，就说明前面不再是最大的字典序）这时就要改变这一位
//举个例子，如123，是最小的顺序，只有最后一位3满足局部的最大字典序，23不满足，因为32比23大。我们如果想上升一位字典序的话，就要将23变成32（这时改变最小）
//同样的道理，如果是231,31是满足的，这时要改变必须改变2。将他变为比他大一点的后面的数，再将后面的数变成最小字典序
//这就像1432变大一位，需要将1换成2然后431变成134。类似十进制的进位=》999 + 1 = 1000，因为前一个位置变大了，紧接着后面的位置应该是最小。

//改变的方法是，先找到刚好比要改变的位置的数字（后面用nums[pr]代替）大或的数字，由于我们已经知道nums[pr]后面是最大的字典序，只需要遍历到小于或者等于nums[pr]
//的数，它的前面一位就是刚好比nums[pr]大的数。交换这两个数，这时，pr所在位置就是刚好比原来的数字大一点，由于原来pr后面就是最大的字典序，而我们交换的时候
//又是找的刚好大一位的数字插在合适的位置，所以后面还应该是最大字典序，所以，交换完成后，我们再讲pr后面逆序，就可以得到最小字典序，这样子就得到了想要的结果

//这题还有关于reverse（arry.[i],arry[i]+l）(l为翻转的长度)翻转的用法，以及交换两个元素swap(a[i],a[j])的用法

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
	int pr = nums.size() - 1;
	int i;
	for (i = nums.size() - 2; i > -1; i--)
	{
		if (nums[i] < nums[i+1])
		{
			pr = i;
			//i = 1;
			break;
		}
	}
	if (i == -1)						//达到停止条件的时候i已经又走了一位了
	{
		reverse(nums.begin(), nums.end());
	}
	else
	{
		for (i = pr + 1; i < nums.size(); i++)
		{
			if (nums[i] <= nums[pr])		//一开始忘记了等于的情况
			{
				swap(nums[i-1], nums[pr]);
				break;
			}
		}
		if (i == nums.size())
		{
			swap(nums[i - 1], nums[pr]);
			//cout << 1 << endl;
		}
		reverse(nums.begin() + pr + 1, nums.end());
	}
}
};