//Aug/4/2018 ac 0ms beats 100%
//如果用回溯这道题会超时，第一时间没有想到利用dp来提高效率
//思想都是一样的，就是对于一个给定的n，出去当前的节点，它的左边和右边分别是i∈[0,n-1]，n-i-1。其中n=0或者n=1的时候答案应为1。这样只需要从0到n-1遍历一次即可
//而每次遍历代表了左边和右边分别有多少种情况，两者相乘就是当前的分配方法总共的分类数目。再将i取0到n-1的所有结果累加起来就是当前n的结果

//而运用回溯和动态规划的最大不同在于，回溯的话每一次分配都需要再回溯到0或者1才能向回开始计算，所以进行很多重复计算
//如果运用动态规划，是从前向后的计算，这样计算后面的结果的时候可以直接取前面的值，不需要再回溯到0或者1.

class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        
        if(n == 0 || n == 1)
        {
            return 1;
        }
        
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i <= n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                dp[i] += dp[j] * dp[i-j-1];
            }
        }
        return dp[n];
    }
};